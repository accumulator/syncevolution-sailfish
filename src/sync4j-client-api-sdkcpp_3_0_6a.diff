? updated.diff
Index: build/autotools/include/Makefile.am
===================================================================
RCS file: /cvsroot/sync4j/3x/client-api/native/build/autotools/include/Makefile.am,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -r1.1 -r1.2
*** build/autotools/include/Makefile.am	12 Jan 2006 11:39:31 -0000	1.1
--- build/autotools/include/Makefile.am	12 Mar 2006 09:37:31 -0000	1.2
***************
*** 45,51 ****
      posix/base/posixlog.h
  
  # fix header files for public distribution
! $(nobase_pkginclude_HEADERS): % : ../../../src/include/%
  	mkdir -p `dirname $@`
  	sed -e 's/wchar_t/char/g' -e 's/__declspec([^)]*)//g' -e 's/__cdecl//g' -e 's/EXTRA_SECTION_[0123456789]*//g' -e 's/BOOL/int/g' -e 's/FALSE/0/g' -e 's/TRUE/1/g' $< >$@
  
--- 45,51 ----
      posix/base/posixlog.h
  
  # fix header files for public distribution
! $(nobase_pkginclude_HEADERS): % : $(srcdir)/../../../src/include/%
  	mkdir -p `dirname $@`
  	sed -e 's/wchar_t/char/g' -e 's/__declspec([^)]*)//g' -e 's/__cdecl//g' -e 's/EXTRA_SECTION_[0123456789]*//g' -e 's/BOOL/int/g' -e 's/FALSE/0/g' -e 's/TRUE/1/g' $< >$@
  
Index: build/autotools/include/Makefile.in
===================================================================
RCS file: /cvsroot/sync4j/3x/client-api/native/build/autotools/include/Makefile.in,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -r1.1 -r1.2
*** build/autotools/include/Makefile.in	13 Jan 2006 17:14:59 -0000	1.1
--- build/autotools/include/Makefile.in	12 Mar 2006 09:37:31 -0000	1.2
***************
*** 428,434 ****
  
  
  # fix header files for public distribution
! $(nobase_pkginclude_HEADERS): % : ../../../src/include/%
  	mkdir -p `dirname $@`
  	sed -e 's/wchar_t/char/g' -e 's/__declspec([^)]*)//g' -e 's/__cdecl//g' -e 's/EXTRA_SECTION_[0123456789]*//g' -e 's/BOOL/int/g' -e 's/FALSE/0/g' -e 's/TRUE/1/g' $< >$@
  
--- 428,434 ----
  
  
  # fix header files for public distribution
! $(nobase_pkginclude_HEADERS): % : $(srcdir)/../../../src/include/%
  	mkdir -p `dirname $@`
  	sed -e 's/wchar_t/char/g' -e 's/__declspec([^)]*)//g' -e 's/__cdecl//g' -e 's/EXTRA_SECTION_[0123456789]*//g' -e 's/BOOL/int/g' -e 's/FALSE/0/g' -e 's/TRUE/1/g' $< >$@
  
Index: build/autotools/src/Makefile.am
===================================================================
RCS file: /cvsroot/sync4j/3x/client-api/native/build/autotools/src/Makefile.am,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -r1.1 -r1.2
*** build/autotools/src/Makefile.am	12 Jan 2006 11:39:31 -0000	1.1
--- build/autotools/src/Makefile.am	12 Mar 2006 09:37:31 -0000	1.2
***************
*** 167,191 ****
  NotifProcessorTest_SOURCES = NotifProcessorTest.cpp
  NotifProcessorTest_LDADD = libsync4j.la
  
! vpath %.cpp ../../../src/c++/common/base             \
!             ../../../src/c++/common/base/util        \
!             ../../../src/c++/common/client           \
!             ../../../src/c++/common/examples         \
!             ../../../src/c++/common/filter           \
!             ../../../src/c++/common/syncml/formatter \
!             ../../../src/c++/common/syncml/core      \
!             ../../../src/c++/common/syncml/parser    \
!             ../../../src/c++/common/http             \
!             ../../../src/c++/common/spdm             \
!             ../../../src/c++/common/spds             \
!             ../../../src/c++/common/vocl             \
!             ../../../src/c++/common/vocl/iCalendar   \
!             ../../../src/c++/common/vocl/vCard       \
!             ../../../src/c++/posix/base              \
!             ../../../src/c++/posix/http              \
!             ../../../src/c++/posix/spdm
  
! vpath %.c   ../../../src/c++/common/base
  
  AM_LDFLAGS = `curl-config --libs`
! AM_CPPFLAGS = -I../../../src/include/posix -I../../../src/include/common -DAUTOTOOLS
--- 167,191 ----
  NotifProcessorTest_SOURCES = NotifProcessorTest.cpp
  NotifProcessorTest_LDADD = libsync4j.la
  
! vpath %.cpp $(srcdir)/../../../src/c++/common/base             \
!             $(srcdir)/../../../src/c++/common/base/util        \
!             $(srcdir)/../../../src/c++/common/client           \
!             $(srcdir)/../../../src/c++/common/examples         \
!             $(srcdir)/../../../src/c++/common/filter           \
!             $(srcdir)/../../../src/c++/common/syncml/formatter \
!             $(srcdir)/../../../src/c++/common/syncml/core      \
!             $(srcdir)/../../../src/c++/common/syncml/parser    \
!             $(srcdir)/../../../src/c++/common/http             \
!             $(srcdir)/../../../src/c++/common/spdm             \
!             $(srcdir)/../../../src/c++/common/spds             \
!             $(srcdir)/../../../src/c++/common/vocl             \
!             $(srcdir)/../../../src/c++/common/vocl/iCalendar   \
!             $(srcdir)/../../../src/c++/common/vocl/vCard       \
!             $(srcdir)/../../../src/c++/posix/base              \
!             $(srcdir)/../../../src/c++/posix/http              \
!             $(srcdir)/../../../src/c++/posix/spdm
  
! vpath %.c   $(srcdir)/../../../src/c++/common/base
  
  AM_LDFLAGS = `curl-config --libs`
! AM_CPPFLAGS = -I$(srcdir)/../../../src/include/posix -I$(srcdir)/../../../src/include/common -DAUTOTOOLS
Index: build/autotools/src/Makefile.in
===================================================================
RCS file: /cvsroot/sync4j/3x/client-api/native/build/autotools/src/Makefile.in,v
retrieving revision 1.1
retrieving revision 1.2
diff -c -r1.1 -r1.2
*** build/autotools/src/Makefile.in	13 Jan 2006 17:14:59 -0000	1.1
--- build/autotools/src/Makefile.in	12 Mar 2006 09:37:31 -0000	1.2
***************
*** 397,403 ****
  NotifProcessorTest_SOURCES = NotifProcessorTest.cpp
  NotifProcessorTest_LDADD = libsync4j.la
  AM_LDFLAGS = `curl-config --libs`
! AM_CPPFLAGS = -I../../../src/include/posix -I../../../src/include/common -DAUTOTOOLS
  all: all-am
  
  .SUFFIXES:
--- 397,403 ----
  NotifProcessorTest_SOURCES = NotifProcessorTest.cpp
  NotifProcessorTest_LDADD = libsync4j.la
  AM_LDFLAGS = `curl-config --libs`
! AM_CPPFLAGS = -I$(srcdir)/../../../src/include/posix -I$(srcdir)/../../../src/include/common -DAUTOTOOLS
  all: all-am
  
  .SUFFIXES:
***************
*** 875,899 ****
  	uninstall-libLTLIBRARIES
  
  
! vpath %.cpp ../../../src/c++/common/base             \
!             ../../../src/c++/common/base/util        \
!             ../../../src/c++/common/client           \
!             ../../../src/c++/common/examples         \
!             ../../../src/c++/common/filter           \
!             ../../../src/c++/common/syncml/formatter \
!             ../../../src/c++/common/syncml/core      \
!             ../../../src/c++/common/syncml/parser    \
!             ../../../src/c++/common/http             \
!             ../../../src/c++/common/spdm             \
!             ../../../src/c++/common/spds             \
!             ../../../src/c++/common/vocl             \
!             ../../../src/c++/common/vocl/iCalendar   \
!             ../../../src/c++/common/vocl/vCard       \
!             ../../../src/c++/posix/base              \
!             ../../../src/c++/posix/http              \
!             ../../../src/c++/posix/spdm
  
! vpath %.c   ../../../src/c++/common/base
  # Tell versions [3.59,3.63) of GNU make to not export all variables.
  # Otherwise a system limit (for SysV at least) may be exceeded.
  .NOEXPORT:
--- 875,899 ----
  	uninstall-libLTLIBRARIES
  
  
! vpath %.cpp $(srcdir)/../../../src/c++/common/base             \
!             $(srcdir)/../../../src/c++/common/base/util        \
!             $(srcdir)/../../../src/c++/common/client           \
!             $(srcdir)/../../../src/c++/common/examples         \
!             $(srcdir)/../../../src/c++/common/filter           \
!             $(srcdir)/../../../src/c++/common/syncml/formatter \
!             $(srcdir)/../../../src/c++/common/syncml/core      \
!             $(srcdir)/../../../src/c++/common/syncml/parser    \
!             $(srcdir)/../../../src/c++/common/http             \
!             $(srcdir)/../../../src/c++/common/spdm             \
!             $(srcdir)/../../../src/c++/common/spds             \
!             $(srcdir)/../../../src/c++/common/vocl             \
!             $(srcdir)/../../../src/c++/common/vocl/iCalendar   \
!             $(srcdir)/../../../src/c++/common/vocl/vCard       \
!             $(srcdir)/../../../src/c++/posix/base              \
!             $(srcdir)/../../../src/c++/posix/http              \
!             $(srcdir)/../../../src/c++/posix/spdm
  
! vpath %.c   $(srcdir)/../../../src/c++/common/base
  # Tell versions [3.59,3.63) of GNU make to not export all variables.
  # Otherwise a system limit (for SysV at least) may be exceeded.
  .NOEXPORT:
Index: src/c++/common/base/util/KeyValuePair.cpp
===================================================================
RCS file: /cvsroot/sync4j/3x/client-api/native/src/c++/common/base/util/KeyValuePair.cpp,v
retrieving revision 1.1
diff -c -r1.1 KeyValuePair.cpp
*** src/c++/common/base/util/KeyValuePair.cpp	12 Jan 2006 11:39:31 -0000	1.1
--- src/c++/common/base/util/KeyValuePair.cpp	18 Mar 2006 18:04:03 -0000
***************
*** 20,26 ****
  #include "base/util/utils.h"
  #include "base/util/KeyValuePair.h"
  
! KeyValuePair::KeyValuePair(wchar_t* key, wchar_t* value) {
      k = (key  ) ? stringdup(key  ) : NULL;
      v = (value) ? stringdup(value) : NULL;
  }
--- 20,26 ----
  #include "base/util/utils.h"
  #include "base/util/KeyValuePair.h"
  
! KeyValuePair::KeyValuePair(const wchar_t* key, const wchar_t* value) {
      k = (key  ) ? stringdup(key  ) : NULL;
      v = (value) ? stringdup(value) : NULL;
  }
***************
*** 30,36 ****
      if (v) delete [] v; v = NULL;
  }
  
! void KeyValuePair::setKey(wchar_t* key) {
      if (k) delete[] k; k = NULL;
  
      k = (key) ? stringdup(key) : NULL;
--- 30,36 ----
      if (v) delete [] v; v = NULL;
  }
  
! void KeyValuePair::setKey(const wchar_t* key) {
      if (k) delete[] k; k = NULL;
  
      k = (key) ? stringdup(key) : NULL;
***************
*** 44,50 ****
      return v;
  }
  
! void KeyValuePair::setValue(wchar_t* value) {
      if (v) delete[] v; v = NULL;
  
      k = (value) ? stringdup(value) : NULL;
--- 44,50 ----
      return v;
  }
  
! void KeyValuePair::setValue(const wchar_t* value) {
      if (v) delete[] v; v = NULL;
  
      k = (value) ? stringdup(value) : NULL;
Index: src/c++/common/vocl/VConverter.cpp
===================================================================
RCS file: /cvsroot/sync4j/3x/client-api/native/src/c++/common/vocl/VConverter.cpp,v
retrieving revision 1.1
diff -c -r1.1 VConverter.cpp
*** src/c++/common/vocl/VConverter.cpp	12 Jan 2006 11:39:32 -0000	1.1
--- src/c++/common/vocl/VConverter.cpp	18 Mar 2006 18:04:04 -0000
***************
*** 59,67 ****
      if(!headerIndex)
          return NULL;
      bool quota = false;
      if(quotaIndex && quotaIndex < headerIndex) {
          quota = true;
!         for(int i = int(headerIndex - buffer); i < int(wcslen(buffer)); i++) {
              if(buffer[i] == '"')
                  quota = !quota;
              if(buffer[i] == ':' && !quota) {
--- 59,78 ----
      if(!headerIndex)
          return NULL;
      bool quota = false;
+     // If the header contains a quotation mark,
+     // then rescan it starting directly after the _quotation mark_
+     // (not after the end of the header, as in the original code)
+     // to find the real end of the header.
+     //
+     // The reason for this code apparently is that the simple search above
+     // might have found a headerIndex which points into the middle of
+     // the quoted string.
+     //
+     // A better solution would be to always scan the header properly.
      if(quotaIndex && quotaIndex < headerIndex) {
          quota = true;
!         int len = int(wcslen(buffer));
!         for(int i = int(quotaIndex - buffer) + 1; i < len; i++) {
              if(buffer[i] == '"')
                  quota = !quota;
              if(buffer[i] == ':' && !quota) {
***************
*** 79,85 ****
      wchar_t* header = new wchar_t[wcslen(buffer) + 1];
      buffer[headerIndex - buffer] = '\0';
      wcscpy(header, buffer);
!     wcscpy(buffer, ++headerIndex);
  
      //if the header is folded (in .ics files)
      //we need to remove the folding
--- 90,101 ----
      wchar_t* header = new wchar_t[wcslen(buffer) + 1];
      buffer[headerIndex - buffer] = '\0';
      wcscpy(header, buffer);
!     // Shift the remaing string to the front of the buffer.
!     // Using wcscpy() for that is incorrect because the standard
!     // does not guarantee in which order bytes are moved!
!     // wcscpy(buffer, ++headerIndex);
!     ++headerIndex;
!     memmove(buffer, headerIndex, (wcslen(headerIndex) + 1) * sizeof(*headerIndex));
  
      //if the header is folded (in .ics files)
      //we need to remove the folding
***************
*** 100,106 ****
              if(extractGroup(token, group)) 
                  prop->addParameter(TEXT("GROUP"), group);
              else
!                 delete group; group= NULL;
              prop->setName(token);            
              first = false;
          }
--- 116,122 ----
              if(extractGroup(token, group)) 
                  prop->addParameter(TEXT("GROUP"), group);
              else
!                 delete [] group; group= NULL;
              prop->setName(token);            
              first = false;
          }
***************
*** 119,125 ****
                  prop->addParameter(paramName, paramVal);
                  
                  delete [] paramName; paramName = NULL;
!                 delete paramVal; paramVal = NULL;
              }
              else {
                  prop->addParameter(token,NULL);
--- 135,141 ----
                  prop->addParameter(paramName, paramVal);
                  
                  delete [] paramName; paramName = NULL;
!                 delete [] paramVal; paramVal = NULL;
              }
              else {
                  prop->addParameter(token,NULL);
***************
*** 128,134 ****
          token = wcstok( NULL, seps );
      }
  
!     delete header; header = NULL;
      delete token; token = NULL;
  
      return prop;
--- 144,150 ----
          token = wcstok( NULL, seps );
      }
  
!     delete [] header; header = NULL;
      delete token; token = NULL;
  
      return prop;
***************
*** 213,219 ****
      
      vprop->setValue(value);
      delete [] value; value = NULL;
!     wcscpy(buffer, c+i);
  
  	return true;
  }
--- 229,238 ----
      
      vprop->setValue(value);
      delete [] value; value = NULL;
!     // wcscpy only valid for non-overlapping buffers.
!     // This one here can overlap.
!     // wcscpy(buffer, c+i);
!     memmove(buffer, c+i, (wcslen(c+i) + 1) * sizeof(*c));
  
  	return true;
  }
Index: src/c++/common/vocl/VObject.cpp
===================================================================
RCS file: /cvsroot/sync4j/3x/client-api/native/src/c++/common/vocl/VObject.cpp,v
retrieving revision 1.1
diff -c -r1.1 VObject.cpp
*** src/c++/common/vocl/VObject.cpp	12 Jan 2006 11:39:32 -0000	1.1
--- src/c++/common/vocl/VObject.cpp	18 Mar 2006 18:04:05 -0000
***************
*** 144,152 ****
              wcscpy(paramName, property->getParameter(k));
  			
              wcscat(strVObject,paramName);
!             if(property->getParameterValue(paramName)) {
                  wcscat(strVObject,TEXT("="));
!                 wcscat(strVObject,property->getParameterValue(paramName));
              }
              delete [] paramName; paramName = NULL;
          }
--- 144,153 ----
              wcscpy(paramName, property->getParameter(k));
  			
              wcscat(strVObject,paramName);
!             const wchar_t *value = property->getParameterValue(k);
!             if(value) {
                  wcscat(strVObject,TEXT("="));
!                 wcscat(strVObject,value);
              }
              delete [] paramName; paramName = NULL;
          }
***************
*** 214,228 ****
--- 215,236 ----
  
  static int hex2int( wchar_t x )
  {
+ 
+     
      return (x >= '0' && x <= '9') ? x - '0' :
          (x >= 'A' && x <= 'F') ? x - 'A' + 10 :
          (x >= 'a' && x <= 'f') ? x - 'a' + 10 :
          0;
  }
  
+ #define SEMICOLON_REPLACEMENT '\a'
+ 
  void VObject::toNativeEncoding()
  {
      BOOL is_30 = !wcscmp(getVersion(), TEXT("3.0"));
+     // line break is encoded with either one or two
+     // characters on different platforms
+     const int linebreaklen = wcslen(SYNC4J_LINEBREAK);
  
      for (int index = propertiesCount() - 1; index >= 0; index--) {
          VProperty *vprop = getProperty(index);
***************
*** 255,260 ****
--- 263,277 ----
                              hex2int(values[1]);
                          out++;
  
+                         // replace \r\n with \n?
+                         if ( linebreaklen == 1 &&
+                              out >= 2 &&
+                              native[out - 2] == '\r' &&
+                              native[out - 1] == '\n' ) {
+                             native[out - 2] = SYNC4J_LINEBREAK[0];
+                             out--;
+                         }
+                         
                          // the conversion to wchar on Windows is
                          // probably missing here
                      }
***************
*** 269,314 ****
              wcscpy(native, foreign);
          }
  
!         if (is_30) {
!             wchar_t curr;
!             int in = 0, out = 0;
!             // line break is encoded with either one or two
!             // characters on different platforms
!             const int linebreaklen = wcslen(SYNC4J_LINEBREAK);
! 
!             while ((curr = native[in]) != 0) {
                  in++;
!                 if (curr == '\\') {
!                     curr = native[in];
!                     in++;
!                     switch (curr) {
!                      case 'n':
                          // replace with line break
                          wcsncpy(native + out, SYNC4J_LINEBREAK, linebreaklen);
                          out += linebreaklen;
!                         break;
!                      case ',':
!                      case '\\':
!                         native[out] = curr;
!                         out++;
!                         break;
!                      case 0:
!                         // unexpected end of string
!                         break;
!                      default:
!                         // just copy next character
                          native[out] = curr;
                          out++;
-                         break;
                      }
!                 } else {
                      native[out] = curr;
                      out++;
                  }
              }
-             native[out] = 0;
-             out++;
          }
  
          vprop->setValue(native);
          delete [] native;
--- 286,336 ----
              wcscpy(native, foreign);
          }
  
!         // decode escaped characters after backslash:
!         // \n is line break only in 3.0
!         wchar_t curr;
!         int in = 0, out = 0;
!         while ((curr = native[in]) != 0) {
!             in++;
!             switch (curr) {
!              case '\\':
!                 curr = native[in];
                  in++;
!                 switch (curr) {
!                  case 'n':
!                     if (is_30) {
                          // replace with line break
                          wcsncpy(native + out, SYNC4J_LINEBREAK, linebreaklen);
                          out += linebreaklen;
!                     } else {
!                         // normal escaped character
                          native[out] = curr;
                          out++;
                      }
!                     break;
!                  case 0:
!                     // unexpected end of string
!                     break;
!                  default:
!                     // just copy next character
                      native[out] = curr;
                      out++;
+                     break;
                  }
+                 break;
+              case ';':
+                 // field separator - must replace with something special
+                 // so that we can encode it again in fromNativeEncoding()
+                 native[out] = SEMICOLON_REPLACEMENT;
+                 out++;
+                 break;
+              default:
+                 native[out] = curr;
+                 out++;
              }
          }
+         native[out] = 0;
+         out++;
  
          vprop->setValue(native);
          delete [] native;
***************
*** 337,398 ****
          // characters on different platforms
          const int linebreaklen = wcslen(SYNC4J_LINEBREAK);
          
!         if (is_30) {
!             // use backslash for special characters
!             while ((curr = native[in]) != 0) {
!                 in++;
!                 switch (curr) {
!                  case ',':
!                  case '\\':
!                     foreign[out] = '\\';
!                     out++;
                      foreign[out] = curr;
                      out++;
                      break;
!                  default:
!                     if (!wcsncmp(native + in - 1,
!                                  SYNC4J_LINEBREAK,
!                                  linebreaklen)) {
!                         // line break
                          foreign[out] = '\\';
                          out++;
                          foreign[out] = 'n';
                          out++;
                      } else {
-                         foreign[out] = curr;
-                         out++;
-                     }
-                     break;
-                 }
-             }
-             foreign[out] = 0;
-             vprop->setValue(foreign);
-         } else {
-             if (wcsstr(native, SYNC4J_LINEBREAK)) {
-                 // replace linebreak with =0D=0A
-                 while ((curr = native[in]) != 0) {
-                     if (!wcsncmp( native + in, SYNC4J_LINEBREAK, linebreaklen)) {
                          wcscpy(foreign + out, TEXT("=0D=0A"));
                          out += 6;
-                         in += linebreaklen;
-                     } else if(curr == '=') {
-                         // escape =
-                         wcsprintf(foreign + out, TEXT("=%02X"), '=');
-                         out += 3;
-                         in++;
-                     } else {
-                         foreign[out] = curr;
-                         out++;
-                         in++;
                      }
                  }
!                 foreign[out] = 0;
!                 vprop->setValue(foreign);
! 
!                 // we have used quoted-printable encoding
!                 vprop->addParameter(TEXT("ENCODING"), TEXT("QUOTED-PRINTABLE"));
              }
          }
          delete [] foreign;
      }
  }
--- 359,422 ----
          // characters on different platforms
          const int linebreaklen = wcslen(SYNC4J_LINEBREAK);
          
!         // use backslash for special characters,
!         // if necessary do quoted-printable encoding
!         bool doquoted = !is_30 &&
!             wcsstr(native, SYNC4J_LINEBREAK) != NULL;
!         while ((curr = native[in]) != 0) {
!             in++;
!             switch (curr) {
!              case ',':
!                 if (!is_30) {
!                     // normal character
                      foreign[out] = curr;
                      out++;
                      break;
!                 }
!                 // no break!
!              case ';':
!              case '\\':
!                 foreign[out] = '\\';
!                 out++;
!                 foreign[out] = curr;
!                 out++;
!                 break;
!              case SEMICOLON_REPLACEMENT:
!                 foreign[out] = ';';
!                 out++;
!                 break;
!              default:
!                 if (doquoted && curr == '=') {
!                     // escape =
!                     wcsprintf(foreign + out, TEXT("=%02X"), '=');
!                     out += 3;
!                 } else if (!wcsncmp(native + in - 1,
!                                     SYNC4J_LINEBREAK,
!                                     linebreaklen)) {
!                     // line break
!                     if (is_30) {
                          foreign[out] = '\\';
                          out++;
                          foreign[out] = 'n';
                          out++;
                      } else {
                          wcscpy(foreign + out, TEXT("=0D=0A"));
                          out += 6;
                      }
+                     in += linebreaklen - 1;
+                 } else {
+                     foreign[out] = curr;
+                     out++;
                  }
!                 break;
              }
          }
+         foreign[out] = 0;
+         vprop->setValue(foreign);
          delete [] foreign;
+         if (doquoted) {
+             // we have used quoted-printable encoding
+             vprop->addParameter(TEXT("ENCODING"), TEXT("QUOTED-PRINTABLE"));
+         }
      }
  }
Index: src/c++/common/vocl/VProperty.cpp
===================================================================
RCS file: /cvsroot/sync4j/3x/client-api/native/src/c++/common/vocl/VProperty.cpp,v
retrieving revision 1.1
diff -c -r1.1 VProperty.cpp
*** src/c++/common/vocl/VProperty.cpp	12 Jan 2006 11:39:32 -0000	1.1
--- src/c++/common/vocl/VProperty.cpp	18 Mar 2006 18:04:05 -0000
***************
*** 40,51 ****
      }
  }	 
  
! void VProperty::setName (wchar_t* s) {
      
      set(&name, s);
  }
  
! void VProperty::setValue (wchar_t* s) {
      
      set(&value, s);
  }
--- 40,51 ----
      }
  }	 
  
! void VProperty::setName (const wchar_t* s) {
      
      set(&name, s);
  }
  
! void VProperty::setValue (const wchar_t* s) {
      
      set(&value, s);
  }
***************
*** 82,88 ****
  	return buf;
  }
  
! void VProperty::addParameter (wchar_t* paramName, wchar_t* paramValue) {
  	
      if(paramName) {
      KeyValuePair *parameter = new KeyValuePair(paramName, paramValue);
--- 82,88 ----
  	return buf;
  }
  
! void VProperty::addParameter (const wchar_t* paramName, const wchar_t* paramValue) {
  	
      if(paramName) {
      KeyValuePair *parameter = new KeyValuePair(paramName, paramValue);
***************
*** 132,139 ****
  
      return NULL;
  }
  
! void VProperty::set(wchar_t** p, wchar_t* v) {
  	
      if (*p) {
          delete [] *p;
--- 132,149 ----
  
      return NULL;
  }
+ wchar_t* VProperty::getParameterValue(int index) {
+     
+     if (parameters != NULL) {
+         KeyValuePair *parameter;
+         parameter = (KeyValuePair*)parameters->get(index);
+         return parameter ? parameter->getValue() : NULL;
+     }
+ 
+     return NULL;
+ }
  
! void VProperty::set(wchar_t** p, const wchar_t* v) {
  	
      if (*p) {
          delete [] *p;
Index: src/include/common/base/util/KeyValuePair.h
===================================================================
RCS file: /cvsroot/sync4j/3x/client-api/native/src/include/common/base/util/KeyValuePair.h,v
retrieving revision 1.1
diff -c -r1.1 KeyValuePair.h
*** src/include/common/base/util/KeyValuePair.h	12 Jan 2006 11:39:34 -0000	1.1
--- src/include/common/base/util/KeyValuePair.h	18 Mar 2006 18:04:05 -0000
***************
*** 29,35 ****
  class KeyValuePair : public ArrayElement {
      public:
  
!         KeyValuePair(wchar_t* key = NULL, wchar_t* value = NULL) EXTRA_SECTION_00;
          ~KeyValuePair() EXTRA_SECTION_00;
  
          ArrayElement* clone() EXTRA_SECTION_00;
--- 29,35 ----
  class KeyValuePair : public ArrayElement {
      public:
  
!         KeyValuePair(const wchar_t* key = NULL, const wchar_t* value = NULL) EXTRA_SECTION_00;
          ~KeyValuePair() EXTRA_SECTION_00;
  
          ArrayElement* clone() EXTRA_SECTION_00;
***************
*** 41,47 ****
           *
           * @param key the new key
           */
!         void setKey(wchar_t* key) EXTRA_SECTION_00;
  
          /**
           * Sets the value. The string is duplicated so that the caller can
--- 41,47 ----
           *
           * @param key the new key
           */
!         void setKey(const wchar_t* key) EXTRA_SECTION_00;
  
          /**
           * Sets the value. The string is duplicated so that the caller can
***************
*** 51,57 ****
           * @param value the new value
           */
  
!         void setValue(wchar_t* value) EXTRA_SECTION_00;
  
          /**
           * Returns the key (the internal buffer address is returned).
--- 51,57 ----
           * @param value the new value
           */
  
!         void setValue(const wchar_t* value) EXTRA_SECTION_00;
  
          /**
           * Returns the key (the internal buffer address is returned).
Index: src/include/common/vocl/VProperty.h
===================================================================
RCS file: /cvsroot/sync4j/3x/client-api/native/src/include/common/vocl/VProperty.h,v
retrieving revision 1.1
diff -c -r1.1 VProperty.h
*** src/include/common/vocl/VProperty.h	12 Jan 2006 11:39:34 -0000	1.1
--- src/include/common/vocl/VProperty.h	18 Mar 2006 18:04:06 -0000
***************
*** 32,38 ****
  
      wchar_t* name;
      wchar_t* value;
!     void set(wchar_t** p, wchar_t* v);
      ArrayList* parameters;
  
   public:       
--- 32,38 ----
  
      wchar_t* name;
      wchar_t* value;
!     void set(wchar_t** p, const wchar_t* v);
      ArrayList* parameters;
  
   public:       
***************
*** 40,53 ****
      VProperty(wchar_t* propName , wchar_t* propValue  = NULL);
      ~VProperty();
      ArrayElement* clone();
!     void setName (wchar_t* name);
!     void setValue (wchar_t* value);
      wchar_t* getName(wchar_t* buf = NULL, int size = -1);
      wchar_t* getValue(wchar_t* buf = NULL, int size = -1);
!     void addParameter(wchar_t* paramName, wchar_t* paramValue);
      void removeParameter(wchar_t* paramName);
      bool containsParameter(wchar_t* paramName);
      wchar_t* getParameterValue(wchar_t* paramName);
      wchar_t* getParameter(int index);
      int parameterCount();
      bool equalsEncoding(wchar_t* encoding);
--- 40,58 ----
      VProperty(wchar_t* propName , wchar_t* propValue  = NULL);
      ~VProperty();
      ArrayElement* clone();
!     void setName (const wchar_t* name);
!     void setValue (const wchar_t* value);
      wchar_t* getName(wchar_t* buf = NULL, int size = -1);
      wchar_t* getValue(wchar_t* buf = NULL, int size = -1);
!     void addParameter(const wchar_t* paramName, const wchar_t* paramValue);
      void removeParameter(wchar_t* paramName);
      bool containsParameter(wchar_t* paramName);
+     // Warning: the name does not always uniquely identify
+     // the parameter, some of them may occur multiple times.
+     // Use getParameterValue(int index) to get the value which
+     // corresponds to a specific parameter.
      wchar_t* getParameterValue(wchar_t* paramName);
+     wchar_t* getParameterValue(int index);
      wchar_t* getParameter(int index);
      int parameterCount();
      bool equalsEncoding(wchar_t* encoding);
